{"ast":null,"code":"import { useEffect, useReducer, useRef } from 'react';\n\nfunction useFetch(url, options) {\n  const cache = useRef({});\n  const cancelRequest = useRef(false);\n  const initialState = {\n    error: undefined,\n    data: undefined\n  };\n\n  const fetchReducer = (state, action) => {\n    switch (action.type) {\n      case 'loading':\n        return { ...initialState\n        };\n\n      case 'fetched':\n        return { ...initialState,\n          data: action.payload\n        };\n\n      case 'error':\n        return { ...initialState,\n          error: action.payload\n        };\n\n      default:\n        return state;\n    }\n  };\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState);\n  useEffect(() => {\n    if (!url) return;\n    cancelRequest.current = false;\n\n    const fetchData = async () => {\n      dispatch({\n        type: 'loading'\n      });\n\n      if (cache.current[url]) {\n        dispatch({\n          type: 'fetched',\n          payload: cache.current[url]\n        });\n        return;\n      }\n\n      try {\n        const response = await fetch(url, options);\n\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n\n        const data = await response.json();\n        cache.current[url] = data;\n        if (cancelRequest.current) return;\n        dispatch({\n          type: 'fetched',\n          payload: data\n        });\n      } catch (error) {\n        if (cancelRequest.current) return;\n        dispatch({\n          type: 'error',\n          payload: error\n        });\n      }\n    };\n\n    void fetchData();\n    return () => {\n      cancelRequest.current = true;\n    };\n  }, [url]);\n  return state;\n}\n\nexport default useFetch;","map":{"version":3,"mappings":"AAAA,SAASA,SAAT,EAAoBC,UAApB,EAAgCC,MAAhC,QAA8C,OAA9C;;AAeA,SAASC,QAAT,CAA+BC,GAA/B,EAA6CC,OAA7C,EAAkE;EAChE,MAAMC,KAAK,GAAGJ,MAAM,CAAW,EAAX,CAApB;EAGA,MAAMK,aAAa,GAAGL,MAAM,CAAU,KAAV,CAA5B;EAEA,MAAMM,YAAY,GAAa;IAC7BC,KAAK,EAAEC,SADsB;IAE7BC,IAAI,EAAED;EAFuB,CAA/B;;EAMA,MAAME,YAAY,GAAG,CAACC,KAAD,EAAkBC,MAAlB,KAAiD;IACpE,QAAQA,MAAM,CAACC,IAAf;MACE,KAAK,SAAL;QACE,OAAO,EAAE,GAAGP;QAAL,CAAP;;MACF,KAAK,SAAL;QACE,OAAO,EAAE,GAAGA,YAAL;UAAmBG,IAAI,EAAEG,MAAM,CAACE;QAAhC,CAAP;;MACF,KAAK,OAAL;QACE,OAAO,EAAE,GAAGR,YAAL;UAAmBC,KAAK,EAAEK,MAAM,CAACE;QAAjC,CAAP;;MACF;QACE,OAAOH,KAAP;IARJ;EAUD,CAXD;;EAaA,MAAM,CAACA,KAAD,EAAQI,QAAR,IAAoBhB,UAAU,CAACW,YAAD,EAAeJ,YAAf,CAApC;EAEAR,SAAS,CAAC,MAAK;IAEb,IAAI,CAACI,GAAL,EAAU;IAEVG,aAAa,CAACW,OAAd,GAAwB,KAAxB;;IAEA,MAAMC,SAAS,GAAG,YAAW;MAC3BF,QAAQ,CAAC;QAAEF,IAAI,EAAE;MAAR,CAAD,CAAR;;MAGA,IAAIT,KAAK,CAACY,OAAN,CAAcd,GAAd,CAAJ,EAAwB;QACtBa,QAAQ,CAAC;UAAEF,IAAI,EAAE,SAAR;UAAmBC,OAAO,EAAEV,KAAK,CAACY,OAAN,CAAcd,GAAd;QAA5B,CAAD,CAAR;QACA;MACD;;MAED,IAAI;QACF,MAAMgB,QAAQ,GAAG,MAAMC,KAAK,CAACjB,GAAD,EAAMC,OAAN,CAA5B;;QACA,IAAI,CAACe,QAAQ,CAACE,EAAd,EAAkB;UAChB,MAAM,IAAIC,KAAJ,CAAUH,QAAQ,CAACI,UAAnB,CAAN;QACD;;QAED,MAAMb,IAAI,GAAI,MAAMS,QAAQ,CAACK,IAAT,EAApB;QACAnB,KAAK,CAACY,OAAN,CAAcd,GAAd,IAAqBO,IAArB;QACA,IAAIJ,aAAa,CAACW,OAAlB,EAA2B;QAE3BD,QAAQ,CAAC;UAAEF,IAAI,EAAE,SAAR;UAAmBC,OAAO,EAAEL;QAA5B,CAAD,CAAR;MACD,CAXD,CAWE,OAAOF,KAAP,EAAc;QACd,IAAIF,aAAa,CAACW,OAAlB,EAA2B;QAE3BD,QAAQ,CAAC;UAAEF,IAAI,EAAE,OAAR;UAAiBC,OAAO,EAAEP;QAA1B,CAAD,CAAR;MACD;IACF,CAzBD;;IA2BA,KAAKU,SAAS,EAAd;IAIA,OAAO,MAAK;MACVZ,aAAa,CAACW,OAAd,GAAwB,IAAxB;IACD,CAFD;EAID,CAzCQ,EAyCN,CAACd,GAAD,CAzCM,CAAT;EA2CA,OAAOS,KAAP;AACD;;AAED,eAAeV,QAAf","names":["useEffect","useReducer","useRef","useFetch","url","options","cache","cancelRequest","initialState","error","undefined","data","fetchReducer","state","action","type","payload","dispatch","current","fetchData","response","fetch","ok","Error","statusText","json"],"sources":["/Users/igor_acb/BxBlue_Igor/front_end/node_modules/usehooks-ts/src/useFetch/useFetch.ts"],"sourcesContent":["import { useEffect, useReducer, useRef } from 'react'\n\ninterface State<T> {\n  data?: T\n  error?: Error\n}\n\ntype Cache<T> = { [url: string]: T }\n\n// discriminated union type\ntype Action<T> =\n  | { type: 'loading' }\n  | { type: 'fetched'; payload: T }\n  | { type: 'error'; payload: Error }\n\nfunction useFetch<T = unknown>(url?: string, options?: RequestInit): State<T> {\n  const cache = useRef<Cache<T>>({})\n\n  // Used to prevent state update if the component is unmounted\n  const cancelRequest = useRef<boolean>(false)\n\n  const initialState: State<T> = {\n    error: undefined,\n    data: undefined,\n  }\n\n  // Keep state logic separated\n  const fetchReducer = (state: State<T>, action: Action<T>): State<T> => {\n    switch (action.type) {\n      case 'loading':\n        return { ...initialState }\n      case 'fetched':\n        return { ...initialState, data: action.payload }\n      case 'error':\n        return { ...initialState, error: action.payload }\n      default:\n        return state\n    }\n  }\n\n  const [state, dispatch] = useReducer(fetchReducer, initialState)\n\n  useEffect(() => {\n    // Do nothing if the url is not given\n    if (!url) return\n\n    cancelRequest.current = false\n\n    const fetchData = async () => {\n      dispatch({ type: 'loading' })\n\n      // If a cache exists for this url, return it\n      if (cache.current[url]) {\n        dispatch({ type: 'fetched', payload: cache.current[url] })\n        return\n      }\n\n      try {\n        const response = await fetch(url, options)\n        if (!response.ok) {\n          throw new Error(response.statusText)\n        }\n\n        const data = (await response.json()) as T\n        cache.current[url] = data\n        if (cancelRequest.current) return\n\n        dispatch({ type: 'fetched', payload: data })\n      } catch (error) {\n        if (cancelRequest.current) return\n\n        dispatch({ type: 'error', payload: error as Error })\n      }\n    }\n\n    void fetchData()\n\n    // Use the cleanup function for avoiding a possibly...\n    // ...state update after the component was unmounted\n    return () => {\n      cancelRequest.current = true\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [url])\n\n  return state\n}\n\nexport default useFetch\n"]},"metadata":{},"sourceType":"module"}