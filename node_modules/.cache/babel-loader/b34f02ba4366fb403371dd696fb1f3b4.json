{"ast":null,"code":"import { useCallback, useEffect, useState } from 'react';\nimport { useEventCallback } from '../useEventCallback';\nimport { useEventListener } from '../useEventListener';\n\nfunction useSessionStorage(key, initialValue) {\n  const readValue = useCallback(() => {\n    if (typeof window === 'undefined') {\n      return initialValue;\n    }\n\n    try {\n      const item = window.sessionStorage.getItem(key);\n      return item ? parseJSON(item) : initialValue;\n    } catch (error) {\n      console.warn(`Error reading sessionStorage key “${key}”:`, error);\n      return initialValue;\n    }\n  }, [initialValue, key]);\n  const [storedValue, setStoredValue] = useState(readValue);\n  const setValue = useEventCallback(value => {\n    if (typeof window == 'undefined') {\n      console.warn(`Tried setting sessionStorage key “${key}” even though environment is not a client`);\n    }\n\n    try {\n      const newValue = value instanceof Function ? value(storedValue) : value;\n      window.sessionStorage.setItem(key, JSON.stringify(newValue));\n      setStoredValue(newValue);\n      window.dispatchEvent(new Event('session-storage'));\n    } catch (error) {\n      console.warn(`Error setting sessionStorage key “${key}”:`, error);\n    }\n  });\n  useEffect(() => {\n    setStoredValue(readValue());\n  }, []);\n  const handleStorageChange = useCallback(event => {\n    if (event?.key && event.key !== key) {\n      return;\n    }\n\n    setStoredValue(readValue());\n  }, [key, readValue]);\n  useEventListener('storage', handleStorageChange);\n  useEventListener('session-storage', handleStorageChange);\n  return [storedValue, setValue];\n}\n\nexport default useSessionStorage;\n\nfunction parseJSON(value) {\n  try {\n    return value === 'undefined' ? undefined : JSON.parse(value ?? '');\n  } catch {\n    console.log('parsing error on', {\n      value\n    });\n    return undefined;\n  }\n}","map":{"version":3,"mappings":"AAAA,SAGEA,WAHF,EAIEC,SAJF,EAKEC,QALF,QAMO,OANP;AAQA,SAASC,gBAAT,QAAiC,qBAAjC;AAEA,SAASC,gBAAT,QAAiC,qBAAjC;;AAUA,SAASC,iBAAT,CAA8BC,GAA9B,EAA2CC,YAA3C,EAA0D;EAGxD,MAAMC,SAAS,GAAGR,WAAW,CAAC,MAAQ;IAEpC,IAAI,OAAOS,MAAP,KAAkB,WAAtB,EAAmC;MACjC,OAAOF,YAAP;IACD;;IAED,IAAI;MACF,MAAMG,IAAI,GAAGD,MAAM,CAACE,cAAP,CAAsBC,OAAtB,CAA8BN,GAA9B,CAAb;MACA,OAAOI,IAAI,GAAIG,SAAS,CAACH,IAAD,CAAb,GAA4BH,YAAvC;IACD,CAHD,CAGE,OAAOO,KAAP,EAAc;MACdC,OAAO,CAACC,IAAR,CAAa,qCAAqCV,GAAG,IAArD,EAA2DQ,KAA3D;MACA,OAAOP,YAAP;IACD;EACF,CAb4B,EAa1B,CAACA,YAAD,EAAeD,GAAf,CAb0B,CAA7B;EAiBA,MAAM,CAACW,WAAD,EAAcC,cAAd,IAAgChB,QAAQ,CAAIM,SAAJ,CAA9C;EAIA,MAAMW,QAAQ,GAAgBhB,gBAAgB,CAACiB,KAAK,IAAG;IAErD,IAAI,OAAOX,MAAP,IAAiB,WAArB,EAAkC;MAChCM,OAAO,CAACC,IAAR,CACE,qCAAqCV,GAAG,2CAD1C;IAGD;;IAED,IAAI;MAEF,MAAMe,QAAQ,GAAGD,KAAK,YAAYE,QAAjB,GAA4BF,KAAK,CAACH,WAAD,CAAjC,GAAiDG,KAAlE;MAGAX,MAAM,CAACE,cAAP,CAAsBY,OAAtB,CAA8BjB,GAA9B,EAAmCkB,IAAI,CAACC,SAAL,CAAeJ,QAAf,CAAnC;MAGAH,cAAc,CAACG,QAAD,CAAd;MAGAZ,MAAM,CAACiB,aAAP,CAAqB,IAAIC,KAAJ,CAAU,iBAAV,CAArB;IACD,CAZD,CAYE,OAAOb,KAAP,EAAc;MACdC,OAAO,CAACC,IAAR,CAAa,qCAAqCV,GAAG,IAArD,EAA2DQ,KAA3D;IACD;EACF,CAvB6C,CAA9C;EAyBAb,SAAS,CAAC,MAAK;IACbiB,cAAc,CAACV,SAAS,EAAV,CAAd;EAED,CAHQ,EAGN,EAHM,CAAT;EAKA,MAAMoB,mBAAmB,GAAG5B,WAAW,CACpC6B,KAAD,IAAsC;IACpC,IAAKA,KAAsB,EAAEvB,GAAxB,IAAgCuB,KAAsB,CAACvB,GAAvB,KAA+BA,GAApE,EAAyE;MACvE;IACD;;IACDY,cAAc,CAACV,SAAS,EAAV,CAAd;EACD,CANoC,EAOrC,CAACF,GAAD,EAAME,SAAN,CAPqC,CAAvC;EAWAJ,gBAAgB,CAAC,SAAD,EAAYwB,mBAAZ,CAAhB;EAIAxB,gBAAgB,CAAC,iBAAD,EAAoBwB,mBAApB,CAAhB;EAEA,OAAO,CAACX,WAAD,EAAcE,QAAd,CAAP;AACD;;AAED,eAAed,iBAAf;;AAGA,SAASQ,SAAT,CAAsBO,KAAtB,EAA0C;EACxC,IAAI;IACF,OAAOA,KAAK,KAAK,WAAV,GAAwBU,SAAxB,GAAoCN,IAAI,CAACO,KAAL,CAAWX,KAAK,IAAI,EAApB,CAA3C;EACD,CAFD,CAEE,MAAM;IACNL,OAAO,CAACiB,GAAR,CAAY,kBAAZ,EAAgC;MAAEZ;IAAF,CAAhC;IACA,OAAOU,SAAP;EACD;AACF","names":["useCallback","useEffect","useState","useEventCallback","useEventListener","useSessionStorage","key","initialValue","readValue","window","item","sessionStorage","getItem","parseJSON","error","console","warn","storedValue","setStoredValue","setValue","value","newValue","Function","setItem","JSON","stringify","dispatchEvent","Event","handleStorageChange","event","undefined","parse","log"],"sources":["/Users/igor_acb/BxBlue_Igor/front_end/node_modules/usehooks-ts/src/useSessionStorage/useSessionStorage.ts"],"sourcesContent":["import {\n  Dispatch,\n  SetStateAction,\n  useCallback,\n  useEffect,\n  useState,\n} from 'react'\n\nimport { useEventCallback } from '../useEventCallback'\n// See: https://usehooks-ts.com/react-hook/use-event-listener\nimport { useEventListener } from '../useEventListener'\n\ndeclare global {\n  interface WindowEventMap {\n    'session-storage': CustomEvent\n  }\n}\n\ntype SetValue<T> = Dispatch<SetStateAction<T>>\n\nfunction useSessionStorage<T>(key: string, initialValue: T): [T, SetValue<T>] {\n  // Get from session storage then\n  // parse stored json or return initialValue\n  const readValue = useCallback((): T => {\n    // Prevent build error \"window is undefined\" but keep keep working\n    if (typeof window === 'undefined') {\n      return initialValue\n    }\n\n    try {\n      const item = window.sessionStorage.getItem(key)\n      return item ? (parseJSON(item) as T) : initialValue\n    } catch (error) {\n      console.warn(`Error reading sessionStorage key “${key}”:`, error)\n      return initialValue\n    }\n  }, [initialValue, key])\n\n  // State to store our value\n  // Pass initial state function to useState so logic is only executed once\n  const [storedValue, setStoredValue] = useState<T>(readValue)\n\n  // Return a wrapped version of useState's setter function that ...\n  // ... persists the new value to sessionStorage.\n  const setValue: SetValue<T> = useEventCallback(value => {\n    // Prevent build error \"window is undefined\" but keeps working\n    if (typeof window == 'undefined') {\n      console.warn(\n        `Tried setting sessionStorage key “${key}” even though environment is not a client`,\n      )\n    }\n\n    try {\n      // Allow value to be a function so we have the same API as useState\n      const newValue = value instanceof Function ? value(storedValue) : value\n\n      // Save to session storage\n      window.sessionStorage.setItem(key, JSON.stringify(newValue))\n\n      // Save state\n      setStoredValue(newValue)\n\n      // We dispatch a custom event so every useSessionStorage hook are notified\n      window.dispatchEvent(new Event('session-storage'))\n    } catch (error) {\n      console.warn(`Error setting sessionStorage key “${key}”:`, error)\n    }\n  })\n\n  useEffect(() => {\n    setStoredValue(readValue())\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [])\n\n  const handleStorageChange = useCallback(\n    (event: StorageEvent | CustomEvent) => {\n      if ((event as StorageEvent)?.key && (event as StorageEvent).key !== key) {\n        return\n      }\n      setStoredValue(readValue())\n    },\n    [key, readValue],\n  )\n\n  // this only works for other documents, not the current one\n  useEventListener('storage', handleStorageChange)\n\n  // this is a custom event, triggered in writeValueTosessionStorage\n  // See: useSessionStorage()\n  useEventListener('session-storage', handleStorageChange)\n\n  return [storedValue, setValue]\n}\n\nexport default useSessionStorage\n\n// A wrapper for \"JSON.parse()\"\" to support \"undefined\" value\nfunction parseJSON<T>(value: string | null): T | undefined {\n  try {\n    return value === 'undefined' ? undefined : JSON.parse(value ?? '')\n  } catch {\n    console.log('parsing error on', { value })\n    return undefined\n  }\n}\n"]},"metadata":{},"sourceType":"module"}